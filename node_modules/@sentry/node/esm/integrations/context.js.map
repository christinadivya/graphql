{"version":3,"file":"context.js","sources":["../../../src/integrations/context.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport {\n  AppContext,\n  Contexts,\n  CultureContext,\n  DeviceContext,\n  Event,\n  EventProcessor,\n  Integration,\n  OsContext,\n} from '@sentry/types';\nimport { execFile } from 'child_process';\nimport { readdir, readFile } from 'fs';\nimport * as os from 'os';\nimport { join } from 'path';\nimport { promisify } from 'util';\n\n// TODO: Required until we drop support for Node v8\nexport const readFileAsync = promisify(readFile);\nexport const readDirAsync = promisify(readdir);\n\ninterface DeviceContextOptions {\n  cpu?: boolean;\n  memory?: boolean;\n}\n\ninterface ContextOptions {\n  app?: boolean;\n  os?: boolean;\n  device?: DeviceContextOptions | boolean;\n  culture?: boolean;\n}\n\n/** Add node modules / packages to the event */\nexport class Context implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Context';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Context.id;\n\n  /**\n   * Caches context so it's only evaluated once\n   */\n  private _cachedContext: Promise<Contexts> | undefined;\n\n  public constructor(private readonly _options: ContextOptions = { app: true, os: true, device: true, culture: true }) {\n    //\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void): void {\n    addGlobalEventProcessor(event => this.addContext(event));\n  }\n\n  /** Processes an event and adds context */\n  public async addContext(event: Event): Promise<Event> {\n    if (this._cachedContext === undefined) {\n      this._cachedContext = this._getContexts();\n    }\n\n    const updatedContext = this._updateContext(await this._cachedContext);\n\n    event.contexts = {\n      ...event.contexts,\n      app: { ...updatedContext.app, ...event.contexts?.app },\n      os: { ...updatedContext.os, ...event.contexts?.os },\n      device: { ...updatedContext.device, ...event.contexts?.device },\n      culture: { ...updatedContext.culture, ...event.contexts?.culture },\n    };\n\n    return event;\n  }\n\n  /**\n   * Updates the context with dynamic values that can change\n   */\n  private _updateContext(contexts: Contexts): Contexts {\n    // Only update properties if they exist\n    if (contexts?.app?.app_memory) {\n      contexts.app.app_memory = process.memoryUsage().rss;\n    }\n\n    if (contexts?.device?.free_memory) {\n      contexts.device.free_memory = os.freemem();\n    }\n\n    return contexts;\n  }\n\n  /**\n   * Gets the contexts for the current environment\n   */\n  private async _getContexts(): Promise<Contexts> {\n    const contexts: Contexts = {};\n\n    if (this._options.os) {\n      contexts.os = await getOsContext();\n    }\n\n    if (this._options.app) {\n      contexts.app = getAppContext();\n    }\n\n    if (this._options.device) {\n      contexts.device = getDeviceContext(this._options.device);\n    }\n\n    if (this._options.culture) {\n      const culture = getCultureContext();\n\n      if (culture) {\n        contexts.culture = culture;\n      }\n    }\n\n    return contexts;\n  }\n}\n\n/**\n * Returns the operating system context.\n *\n * Based on the current platform, this uses a different strategy to provide the\n * most accurate OS information. Since this might involve spawning subprocesses\n * or accessing the file system, this should only be executed lazily and cached.\n *\n *  - On macOS (Darwin), this will execute the `sw_vers` utility. The context\n *    has a `name`, `version`, `build` and `kernel_version` set.\n *  - On Linux, this will try to load a distribution release from `/etc` and set\n *    the `name`, `version` and `kernel_version` fields.\n *  - On all other platforms, only a `name` and `version` will be returned. Note\n *    that `version` might actually be the kernel version.\n */\nasync function getOsContext(): Promise<OsContext> {\n  const platformId = os.platform();\n  switch (platformId) {\n    case 'darwin':\n      return getDarwinInfo();\n    case 'linux':\n      return getLinuxInfo();\n    default:\n      return {\n        name: PLATFORM_NAMES[platformId] || platformId,\n        version: os.release(),\n      };\n  }\n}\n\nfunction getCultureContext(): CultureContext | undefined {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    if (typeof (process.versions as unknown as any).icu !== 'string') {\n      // Node was built without ICU support\n      return;\n    }\n\n    // Check that node was built with full Intl support. Its possible it was built without support for non-English\n    // locales which will make resolvedOptions inaccurate\n    //\n    // https://nodejs.org/api/intl.html#detecting-internationalization-support\n    const january = new Date(9e8);\n    const spanish = new Intl.DateTimeFormat('es', { month: 'long' });\n    if (spanish.format(january) === 'enero') {\n      const options = Intl.DateTimeFormat().resolvedOptions();\n\n      return {\n        locale: options.locale,\n        timezone: options.timeZone,\n      };\n    }\n  } catch (err) {\n    //\n  }\n\n  return;\n}\n\nfunction getAppContext(): AppContext {\n  const app_memory = process.memoryUsage().rss;\n  const app_start_time = new Date(Date.now() - process.uptime() * 1000).toISOString();\n\n  return { app_start_time, app_memory };\n}\n\nfunction getDeviceContext(deviceOpt: DeviceContextOptions | true): DeviceContext {\n  const device: DeviceContext = {};\n\n  device.boot_time = new Date(Date.now() - os.uptime() * 1000).toISOString();\n  device.arch = os.arch();\n\n  if (deviceOpt === true || deviceOpt.memory) {\n    device.memory_size = os.totalmem();\n    device.free_memory = os.freemem();\n  }\n\n  if (deviceOpt === true || deviceOpt.cpu) {\n    const cpuInfo: os.CpuInfo[] | undefined = os.cpus();\n    if (cpuInfo && cpuInfo.length) {\n      const firstCpu = cpuInfo[0];\n\n      device.processor_count = cpuInfo.length;\n      device.cpu_description = firstCpu.model;\n      device.processor_frequency = firstCpu.speed;\n    }\n  }\n\n  return device;\n}\n\n/** Mapping of Node's platform names to actual OS names. */\nconst PLATFORM_NAMES: { [platform: string]: string } = {\n  aix: 'IBM AIX',\n  freebsd: 'FreeBSD',\n  openbsd: 'OpenBSD',\n  sunos: 'SunOS',\n  win32: 'Windows',\n};\n\n/** Linux version file to check for a distribution. */\ninterface DistroFile {\n  /** The file name, located in `/etc`. */\n  name: string;\n  /** Potential distributions to check. */\n  distros: string[];\n}\n\n/** Mapping of linux release files located in /etc to distributions. */\nconst LINUX_DISTROS: DistroFile[] = [\n  { name: 'fedora-release', distros: ['Fedora'] },\n  { name: 'redhat-release', distros: ['Red Hat Linux', 'Centos'] },\n  { name: 'redhat_version', distros: ['Red Hat Linux'] },\n  { name: 'SuSE-release', distros: ['SUSE Linux'] },\n  { name: 'lsb-release', distros: ['Ubuntu Linux', 'Arch Linux'] },\n  { name: 'debian_version', distros: ['Debian'] },\n  { name: 'debian_release', distros: ['Debian'] },\n  { name: 'arch-release', distros: ['Arch Linux'] },\n  { name: 'gentoo-release', distros: ['Gentoo Linux'] },\n  { name: 'novell-release', distros: ['SUSE Linux'] },\n  { name: 'alpine-release', distros: ['Alpine Linux'] },\n];\n\n/** Functions to extract the OS version from Linux release files. */\nconst LINUX_VERSIONS: {\n  [identifier: string]: (content: string) => string | undefined;\n} = {\n  alpine: content => content,\n  arch: content => matchFirst(/distrib_release=(.*)/, content),\n  centos: content => matchFirst(/release ([^ ]+)/, content),\n  debian: content => content,\n  fedora: content => matchFirst(/release (..)/, content),\n  mint: content => matchFirst(/distrib_release=(.*)/, content),\n  red: content => matchFirst(/release ([^ ]+)/, content),\n  suse: content => matchFirst(/VERSION = (.*)\\n/, content),\n  ubuntu: content => matchFirst(/distrib_release=(.*)/, content),\n};\n\n/**\n * Executes a regular expression with one capture group.\n *\n * @param regex A regular expression to execute.\n * @param text Content to execute the RegEx on.\n * @returns The captured string if matched; otherwise undefined.\n */\nfunction matchFirst(regex: RegExp, text: string): string | undefined {\n  const match = regex.exec(text);\n  return match ? match[1] : undefined;\n}\n\n/** Loads the macOS operating system context. */\nasync function getDarwinInfo(): Promise<OsContext> {\n  // Default values that will be used in case no operating system information\n  // can be loaded. The default version is computed via heuristics from the\n  // kernel version, but the build ID is missing.\n  const darwinInfo: OsContext = {\n    kernel_version: os.release(),\n    name: 'Mac OS X',\n    version: `10.${Number(os.release().split('.')[0]) - 4}`,\n  };\n\n  try {\n    // We try to load the actual macOS version by executing the `sw_vers` tool.\n    // This tool should be available on every standard macOS installation. In\n    // case this fails, we stick with the values computed above.\n\n    const output = await new Promise<string>((resolve, reject) => {\n      execFile('/usr/bin/sw_vers', (error: Error | null, stdout: string) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        resolve(stdout);\n      });\n    });\n\n    darwinInfo.name = matchFirst(/^ProductName:\\s+(.*)$/m, output);\n    darwinInfo.version = matchFirst(/^ProductVersion:\\s+(.*)$/m, output);\n    darwinInfo.build = matchFirst(/^BuildVersion:\\s+(.*)$/m, output);\n  } catch (e) {\n    // ignore\n  }\n\n  return darwinInfo;\n}\n\n/** Returns a distribution identifier to look up version callbacks. */\nfunction getLinuxDistroId(name: string): string {\n  return name.split(' ')[0].toLowerCase();\n}\n\n/** Loads the Linux operating system context. */\nasync function getLinuxInfo(): Promise<OsContext> {\n  // By default, we cannot assume anything about the distribution or Linux\n  // version. `os.release()` returns the kernel version and we assume a generic\n  // \"Linux\" name, which will be replaced down below.\n  const linuxInfo: OsContext = {\n    kernel_version: os.release(),\n    name: 'Linux',\n  };\n\n  try {\n    // We start guessing the distribution by listing files in the /etc\n    // directory. This is were most Linux distributions (except Knoppix) store\n    // release files with certain distribution-dependent meta data. We search\n    // for exactly one known file defined in `LINUX_DISTROS` and exit if none\n    // are found. In case there are more than one file, we just stick with the\n    // first one.\n    const etcFiles = await readDirAsync('/etc');\n    const distroFile = LINUX_DISTROS.find(file => etcFiles.includes(file.name));\n    if (!distroFile) {\n      return linuxInfo;\n    }\n\n    // Once that file is known, load its contents. To make searching in those\n    // files easier, we lowercase the file contents. Since these files are\n    // usually quite small, this should not allocate too much memory and we only\n    // hold on to it for a very short amount of time.\n    const distroPath = join('/etc', distroFile.name);\n    const contents = ((await readFileAsync(distroPath, { encoding: 'utf-8' })) as string).toLowerCase();\n\n    // Some Linux distributions store their release information in the same file\n    // (e.g. RHEL and Centos). In those cases, we scan the file for an\n    // identifier, that basically consists of the first word of the linux\n    // distribution name (e.g. \"red\" for Red Hat). In case there is no match, we\n    // just assume the first distribution in our list.\n    const { distros } = distroFile;\n    linuxInfo.name = distros.find(d => contents.indexOf(getLinuxDistroId(d)) >= 0) || distros[0];\n\n    // Based on the found distribution, we can now compute the actual version\n    // number. This is different for every distribution, so several strategies\n    // are computed in `LINUX_VERSIONS`.\n    const id = getLinuxDistroId(linuxInfo.name);\n    linuxInfo.version = LINUX_VERSIONS[id](contents);\n  } catch (e) {\n    // ignore\n  }\n\n  return linuxInfo;\n}\n"],"names":[],"mappings":";;;;;;;AAiBA;;;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2FA;;AAEA;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;AAaA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;;AAEA;;;;;AAKA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;AAEA;AACA;;;;;;AAMA;;AAEA;;AAQA;AACA;;;;;;;;;;;;AAYA;;AAEA;AACA;;;;;;;;;;;;AAYA;;AAEA;;;;;;;AAOA;;;AAGA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CA;;"}