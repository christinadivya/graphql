"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SeedCommand = void 0;
const tslib_1 = require("tslib");
const node_path_1 = require("node:path");
const ora_1 = tslib_1.__importDefault(require("ora"));
const typeorm_1 = require("typeorm");
const yargs_1 = require("yargs");
const seeder_1 = require("../seeder");
const useSeeders_1 = require("../helpers/useSeeders");
const fileHandling_1 = require("../utils/fileHandling");
const helpers_1 = require("../helpers");
class SeedCommand {
    constructor() {
        this.command = 'seed <path>';
        this.describe = 'Runs the seeders';
    }
    /**
     * @inheritdoc
     */
    builder(args) {
        return args
            .option('d', {
            alias: 'dataSource',
            type: 'string',
            describe: 'Path to the file where your DataSource instance is defined.',
            required: true,
        })
            .fail((message, error) => {
            if (error)
                throw error; // preserve stack
            else {
                console.error(message);
                (0, yargs_1.showHelp)();
            }
        });
    }
    /**
     * @inheritdoc
     */
    async handler(args) {
        const spinner = (0, ora_1.default)({ isSilent: process.env.NODE_ENV === 'test' }).start();
        spinner.start('Loading datasource');
        let dataSource;
        try {
            const dataSourcePath = (0, node_path_1.resolve)(process.cwd(), args.dataSource);
            dataSource = await SeedCommand.loadDataSource(dataSourcePath);
            spinner.succeed('Datasource loaded');
        }
        catch (error) {
            spinner.fail('Could not load the data source!');
            throw error;
        }
        spinner.start('Importing seeders');
        let seeders;
        try {
            const absolutePath = (0, node_path_1.resolve)(process.cwd(), args.path);
            const seederFiles = (0, fileHandling_1.calculateFilePath)(absolutePath);
            seeders = await SeedCommand.loadSeeders(seederFiles);
            spinner.succeed('Seeder imported');
        }
        catch (error) {
            spinner.fail('Could not load seeders!');
            await dataSource.destroy();
            throw error;
        }
        // Run seeder
        spinner.start(`Executing seeders`);
        try {
            await (0, helpers_1.useDataSource)(dataSource);
            for (const seeder of seeders) {
                await (0, useSeeders_1.useSeeders)(seeder);
                spinner.succeed(`Seeder ${seeder.name} executed`);
            }
        }
        catch (error) {
            spinner.fail('Could not execute seeder!');
            await dataSource.destroy();
            throw error;
        }
        spinner.succeed('Finished seeding');
        await dataSource.destroy();
    }
    static async loadDataSource(dataSourceFilePath) {
        let dataSourceFileExports;
        try {
            dataSourceFileExports = await Promise.resolve().then(() => tslib_1.__importStar(require(dataSourceFilePath)));
        }
        catch (err) {
            throw new Error(`Unable to open file: "${dataSourceFilePath}"`);
        }
        if (!dataSourceFileExports || typeof dataSourceFileExports !== 'object') {
            throw new Error(`Given data source file must contain export of a DataSource instance`);
        }
        const dataSourceExports = [];
        for (const fileExport in dataSourceFileExports) {
            const dataSourceExport = dataSourceFileExports[fileExport];
            if (dataSourceExport instanceof typeorm_1.DataSource) {
                dataSourceExports.push(dataSourceExport);
            }
        }
        if (dataSourceExports.length === 0) {
            throw new Error(`Given data source file must contain export of a DataSource instance`);
        }
        if (dataSourceExports.length > 1) {
            throw new Error(`Given data source file must contain only one export of DataSource instance`);
        }
        const dataSource = dataSourceExports[0];
        dataSource.setOptions({
            synchronize: false,
            migrationsRun: false,
            dropSchema: false,
            logging: false,
        });
        await dataSource.initialize();
        return dataSource;
    }
    static async loadSeeders(seederPaths) {
        let seederFileExports;
        try {
            seederFileExports = await Promise.all(seederPaths.map((seederFile) => Promise.resolve().then(() => tslib_1.__importStar(require(seederFile))))).then((seederExports) => {
                return seederExports
                    .map((seederExport) => seederExport.default)
                    .filter((seederExport) => Boolean(seederExport));
            });
        }
        catch (err) {
            throw new Error(`Unable to open files ${err.message}`);
        }
        if (seederFileExports.length === 0) {
            throw new Error(`No default seeders found`);
        }
        const seeders = [];
        for (const fileExport in seederFileExports) {
            const seederExport = seederFileExports[fileExport];
            const instance = new seederExport();
            if (instance instanceof seeder_1.Seeder) {
                seeders.push(seederExport);
            }
        }
        return seeders;
    }
}
exports.SeedCommand = SeedCommand;
//# sourceMappingURL=seed.command.js.map